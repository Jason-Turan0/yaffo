{
  "files": [
    {
      "filename": "photo_gallery_loads_with_valid_images.spec.ts",
      "code": "import { test, expect } from '@playwright/test';\n\ntest.describe('Photo Gallery - Image Loading', () => {\n  test('gallery loads with valid images', async ({ page }) => {\n    // Navigate to the home page\n    await page.goto('/');\n\n    // Wait for the gallery grid to be visible\n    await expect(page.locator('.photo-grid')).toBeVisible();\n\n    // Verify gallery grid container is visible\n    const galleryGrid = page.locator('.photo-grid');\n    await expect(galleryGrid).toBeVisible();\n\n    // Wait for photos to load and collect all image elements in the gallery\n    await page.waitForSelector('.photo-card img', { timeout: 10000 });\n    const images = page.locator('.photo-card img');\n\n    // Verify at least one photo is displayed\n    const imageCount = await images.count();\n    expect(imageCount).toBeGreaterThan(0);\n\n    // Verify each image source returns HTTP 200\n    for (let i = 0; i < imageCount; i++) {\n      const image = images.nth(i);\n      const imageSrc = await image.getAttribute('src');\n      \n      if (imageSrc) {\n        // Make a HEAD request to check if the image URL is valid\n        const baseUrl = new URL(page.url()).origin;\n        const fullImageUrl = imageSrc.startsWith('http') ? imageSrc : `${baseUrl}${imageSrc}`;\n        \n        const response = await page.request.head(fullImageUrl);\n        expect(response.status()).toBe(200);\n        \n        // Verify the image is not using the fallback placeholder\n        const dataFallback = await image.getAttribute('data-fallback');\n        expect(imageSrc).not.toBe(dataFallback);\n        \n        // Additional check: verify image has loaded by checking naturalWidth\n        const naturalWidth = await image.evaluate((img: HTMLImageElement) => img.naturalWidth);\n        expect(naturalWidth).toBeGreaterThan(0);\n      }\n    }\n\n    // Verify no images are using the fallback placeholder by checking if any images have src equal to data-fallback\n    const placeholderImages = await page.locator('.photo-card img').evaluateAll((images) => {\n      return images.filter((img: HTMLImageElement) => {\n        const src = img.src;\n        const fallback = img.getAttribute('data-fallback');\n        return fallback && src.endsWith(fallback);\n      }).length;\n    });\n    expect(placeholderImages).toBe(0);\n\n    // Verify the photo count is displayed correctly\n    const subtitle = page.locator('.subtitle');\n    await expect(subtitle).toBeVisible();\n    const subtitleText = await subtitle.textContent();\n    expect(subtitleText).toMatch(/Showing \\d+ of \\d+ photos?/);\n  });\n\n  test('gallery handles broken images gracefully', async ({ page }) => {\n    await page.goto('/');\n    \n    // Wait for the gallery to load\n    await expect(page.locator('.photo-grid')).toBeVisible();\n    \n    // Test error handling by intercepting image requests and making some fail\n    await page.route('**/photos/1', route => route.fulfill({ status: 404 }));\n    \n    // Reload to trigger the error\n    await page.reload();\n    \n    // Wait for gallery to load\n    await expect(page.locator('.photo-grid')).toBeVisible();\n    \n    // The gallery should still be functional even with broken images\n    const images = page.locator('.photo-card img');\n    const imageCount = await images.count();\n    expect(imageCount).toBeGreaterThan(0);\n  });\n});",
      "description": "Tests that verify photo gallery loads correctly and all images have valid sources with no broken links"
    },
    {
      "filename": "photo_gallery_year_filter.spec.ts",
      "code": "import { test, expect } from '@playwright/test';\n\ntest.describe('Photo Gallery - Year Filter', () => {\n  test('gallery filter year works', async ({ page }) => {\n    // Navigate to the home page\n    await page.goto('/');\n\n    // Wait for the gallery grid to be visible\n    await expect(page.locator('.photo-grid')).toBeVisible();\n\n    // Verify gallery grid container is visible\n    await expect(page.locator('.photo-grid')).toBeVisible();\n\n    // Get initial photo count\n    const initialSubtitle = page.locator('.subtitle');\n    await expect(initialSubtitle).toBeVisible();\n    const initialText = await initialSubtitle.textContent();\n    const initialCount = parseInt(initialText?.match(/Showing (\\d+) of/)?.[1] || '0');\n    expect(initialCount).toBeGreaterThan(0);\n\n    // Verify at least one year is in the filter dropdown\n    const yearSelect = page.locator('#year-select');\n    await expect(yearSelect).toBeVisible();\n    \n    // Get available years from the dropdown - exclude the \"All Years\" option which has empty value\n    const yearOptions = await page.locator('#year-select option').evaluateAll((options) => {\n      return options\n        .filter((option: HTMLOptionElement) => option.value && option.value.trim() !== '')\n        .map((option: HTMLOptionElement) => ({\n          value: option.value,\n          text: option.textContent?.trim() || ''\n        }));\n    });\n    \n    expect(yearOptions.length).toBeGreaterThan(0);\n\n    // Select the first available year (not \"All Years\")\n    const firstYear = yearOptions[0];\n    \n    await yearSelect.selectOption(firstYear.value);\n\n    // Click Apply Filters\n    const applyButton = page.getByRole('button', { name: 'Apply Filters' });\n    await expect(applyButton).toBeVisible();\n    await applyButton.click();\n\n    // Wait for the page to update after filtering\n    await page.waitForLoadState('networkidle');\n    \n    // Verify URL contains the year parameter\n    expect(page.url()).toContain(`year=${firstYear.value}`);\n\n    // Verify gallery grid is still visible\n    await expect(page.locator('.photo-grid')).toBeVisible();\n\n    // Get filtered photo count\n    await expect(initialSubtitle).toBeVisible();\n    const filteredText = await initialSubtitle.textContent();\n    const filteredCount = parseInt(filteredText?.match(/Showing (\\d+) of/)?.[1] || '0');\n    \n    // Verify we have at least one photo with the filter applied\n    expect(filteredCount).toBeGreaterThan(0);\n\n    // When the filter is applied, verify all images are from that year\n    // by checking that all photo cards show the correct year in their date\n    const photoDates = page.locator('.photo-date');\n    const dateCount = await photoDates.count();\n    \n    if (dateCount > 0) {\n      for (let i = 0; i < dateCount; i++) {\n        const dateText = await photoDates.nth(i).textContent();\n        if (dateText && !dateText.includes('Unknown date')) {\n          // Check that the date contains the selected year\n          expect(dateText).toContain(firstYear.text);\n        }\n      }\n    }\n\n    // Click Clear button\n    const clearButton = page.getByRole('button', { name: 'Clear Filters' });\n    await expect(clearButton).toBeVisible();\n    await clearButton.click();\n\n    // Wait for the page to update after clearing\n    await page.waitForLoadState('networkidle');\n\n    // Verify URL no longer contains year parameter\n    expect(page.url()).not.toContain(`year=${firstYear.value}`);\n\n    // Verify gallery grid is still visible\n    await expect(page.locator('.photo-grid')).toBeVisible();\n\n    // When the filter is cleared, verify all images are shown\n    await expect(initialSubtitle).toBeVisible();\n    const clearedText = await initialSubtitle.textContent();\n    const clearedCount = parseInt(clearedText?.match(/Showing (\\d+) of/)?.[1] || '0');\n    \n    // The cleared count should be equal to or greater than the filtered count\n    expect(clearedCount).toBeGreaterThanOrEqual(filteredCount);\n    \n    // Verify year dropdown is reset to \"All Years\"\n    const selectedOption = await yearSelect.inputValue();\n    expect(selectedOption).toBe('');\n  });\n\n  test('year filter shows correct results for different years', async ({ page }) => {\n    await page.goto('/');\n    \n    // Wait for gallery to load\n    await expect(page.locator('.photo-grid')).toBeVisible();\n    \n    const yearSelect = page.locator('#year-select');\n    const applyButton = page.getByRole('button', { name: 'Apply Filters' });\n    \n    // Get available years from the dropdown - exclude the \"All Years\" option\n    const yearOptions = await page.locator('#year-select option').evaluateAll((options) => {\n      return options\n        .filter((option: HTMLOptionElement) => option.value && option.value.trim() !== '')\n        .map((option: HTMLOptionElement) => ({\n          value: option.value,\n          text: option.textContent?.trim() || ''\n        }));\n    });\n    \n    if (yearOptions.length > 1) {\n      // Test multiple years to ensure filtering works correctly\n      const yearResults: { year: string, count: number }[] = [];\n      \n      for (let i = 0; i < Math.min(yearOptions.length, 2); i++) {\n        const yearOption = yearOptions[i];\n        \n        // Select the year\n        await yearSelect.selectOption(yearOption.value);\n        await applyButton.click();\n        await page.waitForLoadState('networkidle');\n        \n        // Get result count\n        const subtitle = page.locator('.subtitle');\n        const subtitleText = await subtitle.textContent();\n        const count = parseInt(subtitleText?.match(/Showing (\\d+) of/)?.[1] || '0');\n        \n        yearResults.push({ year: yearOption.text, count });\n        \n        // Verify all photos are from the selected year\n        const photoDates = page.locator('.photo-date');\n        const dateCount = await photoDates.count();\n        \n        for (let j = 0; j < dateCount; j++) {\n          const dateText = await photoDates.nth(j).textContent();\n          if (dateText && !dateText.includes('Unknown date')) {\n            expect(dateText).toContain(yearOption.text);\n          }\n        }\n      }\n      \n      // Results should be different for different years (unless all photos are from same year)\n      if (yearResults.length > 1 && yearResults[0].year !== yearResults[1].year) {\n        // At least verify that we got some results for each year tested\n        yearResults.forEach(result => {\n          expect(result.count).toBeGreaterThan(0);\n        });\n      }\n    } else {\n      // If only one year option available, just verify basic filtering works\n      const yearOption = yearOptions[0];\n      await yearSelect.selectOption(yearOption.value);\n      await applyButton.click();\n      await page.waitForLoadState('networkidle');\n      \n      const subtitle = page.locator('.subtitle');\n      const subtitleText = await subtitle.textContent();\n      const count = parseInt(subtitleText?.match(/Showing (\\d+) of/)?.[1] || '0');\n      expect(count).toBeGreaterThan(0);\n    }\n  });\n});",
      "description": "Tests that verify year filtering functionality works correctly, including applying filters and clearing them"
    }
  ],
  "testContext": "Photo gallery application with filtering capabilities. Key elements: .photo-grid (main container), .photo-card (individual photos), #year-select (year filter dropdown), Apply Filters and Clear Filters buttons. Images use /photos/{id} URLs with data-fallback attributes for error handling. Fixed CSS selector issue by using evaluateAll instead of invalid CSS selector.",
  "explanation": "Fixed the main issue causing test failures:\n\n**Root Cause**: The CSS selector `option[value!=\"\"]` is invalid because CSS doesn't support the `!=` (not equal) operator.\n\n**Solution**: Replaced the invalid CSS selector with `page.evaluateAll()` to programmatically filter option elements with JavaScript, checking for non-empty values.\n\n**Key Changes**:\n1. **Replaced invalid CSS selector**: Changed from `page.locator('#year-select option[value!=\"\"]')` to using `evaluateAll()` with JavaScript filtering\n2. **Improved option filtering**: Now properly filters out the \"All Years\" option (which has empty value) and extracts both value and text\n3. **Enhanced error handling**: Added fallback logic for cases where only one year option is available\n4. **Maintained all test functionality**: All original test verification logic remains intact\n\nThe tests now properly:\n- Get available year options excluding \"All Years\"\n- Select valid years for filtering\n- Verify URL parameters and result counts\n- Check that filtered photos match the selected year\n- Test clear filters functionality\n- Handle edge cases like single year scenarios",
  "confidence": 0.98
}